### **希尔排序**
希尔排序是一种改进版的插入排序，普通的插入排序算法中，是从第2个节点开始，依次插入到有序序列中，这种做法虽然“一次成形”，但研究发现时间效率上这么做并不划算，更“划算”的做法是这样的：  

不严格一个个插入使之有序，而是拉开插入节点的距离，让它们逐步有序，比如如下图所示，有无无序列：  

84、83、88、87、61、50、70、60、80、99  

第一遍，先取间隔为（$\Delta=5$），即依次对以下5组数据进行排序：

**84**、83、88、87、61、**50**、70、60、80、99  
84、**83**、88、87、61、50、**70**、60、80、99  
84、83、**88**、87、61、50、70、**60**、80、99  
84、83、88、**87**、61、50、70、60、**80**、99  
84、83、88、87、**61**、50、70、60、80、**99**  

注意，当对84和50进行排序时，其他的元素就像不存在一样。因此，经过上述间隔为5的一遍排序后，数据如下：

**50**、83、88、87、61、**84**、70、60、80、99  
50、**70**、88、87、61、84、**83**、60、80、99  
50、70、**60**、87、61、84、83、**88**、80、99  
50、70、60、**80**、61、84、83、88、**87**、99  
50、70、60、80、**61**、84、83、88、87、**99**  

最终的结果（50、70、60、80、61、84、83、88、87、99）是经过这一遍间隔$\Delta=5$的情况下达成的，接下去缩小间隔重复如上过程。例如让间距$\Delta=3$：

**50**、70、60、**80**、61、84、**83**、88、87、**99**  
50、**70**、60、80、**61**、84、83、**88**、87、99  
50、70、**60**、80、61、**84**、83、88、**87**、99  
50、70、60、**80**、61、84、**83**、88、87、**99**  

将上述粗体的每一组数据进行排序，得到：  

**50**、70、60、**80**、61、84、**83**、88、87、**99**  
50、**61**、60、80、**70**、84、83、**88**、87、99  
50、61、**60**、80、70、**84**、83、88、**87**、99  
50、61、60、**80**、70、84、**83**、88、87、**99**  

最终的结果（50、61、60、80、70、84、83、88、87、99）更加接近完全有序的序列。接下去继续不断减小间隔，最终令$\Delta=1$，确保每一个元素都在恰当的位置。动图展示如下：

<center>
<img src="http://edu.yueqian.com.cn/group1/M00/00/2B/wKgA3V-hBRCAF_E2ABDUlv-P2s8634.gif", width=450>
</center>

示例代码：
```C
#include <stdio.h>
#include <math.h>

int comp_count = 0;
int swap_count = 0;

void show(int data[], int len)
{
    int i;
    for(i=0; i<len; ++i)
    {
        printf("%d\t", data[i]);
    }

    printf("\n");
    return;
}

//                    起点    节点个数    间距
void insert_sort(int data[], int len, int delta)
{
    if(len <= 1)
        return;

    for(int i=delta; i<len*delta; i+=delta)
    {
        int j, tmp = data[i];
        for(j=i-delta; j>=0; j-=delta)
        {
            comp_count++;
            if(data[j] < tmp)
                break;

            swap_count++;
            data[j+delta] = data[j];
        }

        data[j+delta] = tmp;
    }
}

void shell_sort(int data[], int len)
{
    if(len <= 1)
        return;

    for(int delta=len/2; delta>0; delta/=2)
    {
        for(int i=0; i<delta; ++i)
        {
            //           起点     节点个数    间距
            insert_sort(data+i, len/delta, delta);
        }
    }
}

int main(void)
{
    // 准备产生一些随机数
    srand(time(NULL));

    int i, data[100];
    for(i=0; i<100; i++)
    {
        int exp = (int)pow(10, rand()%3+3);
        data[i] = rand()%exp;
    }
    printf("随机序列: ");
    show(data, 100);

    printf("希尔排序: ");
    shell_sort(data, 100);
    show(data, 100);

    printf("总共比较次数: %d\n", comp_count);
    printf("总共移动次数: %d\n", swap_count);

    return 0;
}
```

# <center>「课堂练习5」</center>
使用相关系统函数，产生系列随机数，然后采用**希尔排序**算法，将他们排好序之后输出到屏幕上，并计算排序过程中比较的次数和交换数据的次数。
<center>
<img src="http://edu.yueqian.com.cn/group1/M00/00/28/wKgA3V-ev4OAAA12AAFE4DgleqQ787.jpg", width=300>
</center>